# -*- coding: utf-8 -*-
"""rAAV Production Model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l2fanKSrAtwtRWX7ehZMnXhqksCIlKHE
"""

import numpy as np
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt

def raav_mechanistic_model(t, y, params):
    """
    ODE system for the mechanistic model of rAAV production via triple transfection.
    This model is based on the paper by Nguyen et al., Mol Ther Methods Clin Dev, 2021.
    It includes two main parts:
    1. Plasmid delivery from extracellular space to the nucleus.
    2. Viral vector synthesis inside the nucleus and cytosol.

    Args:
        t (float): Time.
        y (array): Array of species concentrations at time t.
        params (dict): Dictionary of model parameters.

    Returns:
        array: Array of the derivatives (dy/dt) for each species.
    """
    # Unpack the state variables for clarity
    (ExComplex, EndosComplex, CytoComplex, NucPlasmid_H, NucPlasmid_P,
     NucPlasmid_V, NucPlasmid_P_bound, RepProtein, VP, vDNA, EmptyCapNuc,
     CapRepComplex, FullCapNuc, EmptyCapCyto, FullCapCyto) = y

    # Unpack parameters
    k_uptake = params['k_uptake']
    k_escape = params['k_escape']
    k_plasmid_degrade = params['k_plasmid_degrade']
    k_nuclear_entry = params['k_nuclear_entry']
    k_Rep_syn = params['k_Rep_syn']
    k_Cap_syn = params['k_Cap_syn']
    k_VP_degrade = params['k_VP_degrade']
    k_Rep_protein_degrade = params['k_Rep_protein_degrade']
    k_DNA_rep = params['k_DNA_rep']
    k_assembly = params['k_assembly']
    k_secrete = params['k_secrete']
    k_DNA_pack = params['k_DNA_pack']
    k_Rep_bind_plasmid = params['k_Rep_bind_plasmid']
    k_Rep_bind_capsid = params['k_Rep_bind_capsid']
    mu = params['mu']
    plasmid_ratios = params['plasmid_ratios']

    # --- Part 1: Plasmid Delivery ---
    # Equations 1-4 from the paper, adapted for the three plasmid types.
    # The model assumes delivery kinetics are the same for all plasmids.

    d_ExComplex_dt = -k_uptake * ExComplex
    d_EndosComplex_dt = k_uptake * ExComplex - (k_escape + k_plasmid_degrade + mu) * EndosComplex
    d_CytoComplex_dt = k_escape * EndosComplex - (k_nuclear_entry + k_plasmid_degrade + mu) * CytoComplex

    # Rate of total nuclear plasmid entry
    total_nuclear_entry_rate = k_nuclear_entry * CytoComplex

    # Distribute nuclear entry among plasmid types and account for degradation/dilution
    d_NucPlasmid_H_dt = total_nuclear_entry_rate * plasmid_ratios['helper'] - (k_plasmid_degrade + mu) * NucPlasmid_H
    d_NucPlasmid_P_dt = total_nuclear_entry_rate * plasmid_ratios['packaging'] - (k_plasmid_degrade + mu) * NucPlasmid_P - k_Rep_bind_plasmid * RepProtein * NucPlasmid_P
    d_NucPlasmid_V_dt = total_nuclear_entry_rate * plasmid_ratios['vector'] - (k_plasmid_degrade + mu) * NucPlasmid_V

    # --- Part 2: Viral Vector Synthesis ---
    # Equations 5-13 from the paper, with corrections and clarifications based on the text.

    # Rep protein binds to and inactivates the packaging plasmid
    d_NucPlasmid_P_bound_dt = k_Rep_bind_plasmid * RepProtein * NucPlasmid_P - mu * NucPlasmid_P_bound

    # Rep Protein dynamics (Eq. 5)
    rep_synthesis = k_Rep_syn * NucPlasmid_P * NucPlasmid_H
    rep_binding_to_plasmid = k_Rep_bind_plasmid * RepProtein * NucPlasmid_P
    rep_binding_to_capsid = k_Rep_bind_capsid * RepProtein * EmptyCapNuc
    rep_release_after_pack = k_DNA_pack * CapRepComplex * vDNA
    d_RepProtein_dt = (rep_synthesis - rep_binding_to_plasmid - rep_binding_to_capsid +
                       rep_release_after_pack - (k_Rep_protein_degrade + mu) * RepProtein)

    # Viral Protein (VP) dynamics (Eq. 6)
    # VPs are synthesized and then quickly assembled into capsids (60 VPs per capsid).
    vp_synthesis = k_Cap_syn * NucPlasmid_P * NucPlasmid_H
    vp_assembly = 60 * k_assembly * VP
    d_VP_dt = vp_synthesis - vp_assembly - (k_VP_degrade + mu) * VP

    # Viral DNA (vDNA) replication (Eq. 7)
    vDNA_replication = k_DNA_rep * RepProtein * NucPlasmid_H * NucPlasmid_V
    vDNA_packaging = k_DNA_pack * CapRepComplex * vDNA
    d_vDNA_dt = vDNA_replication - vDNA_packaging - mu * vDNA

    # Empty Capsid in Nucleus dynamics (Eq. 8)
    empty_capsid_assembly = k_assembly * VP
    d_EmptyCapNuc_dt = (empty_capsid_assembly - rep_binding_to_capsid -
                        (k_secrete + mu) * EmptyCapNuc)

    # Intermediate Complex (Rep docked on capsid) dynamics (Eq. 13)
    complex_formation = rep_binding_to_capsid
    complex_consumption = vDNA_packaging
    d_CapRepComplex_dt = complex_formation - complex_consumption - mu * CapRepComplex

    # Full Capsid in Nucleus dynamics (Corrected from Eq. 9)
    full_capsid_formation = vDNA_packaging
    d_FullCapNuc_dt = full_capsid_formation - (k_secrete + mu) * FullCapNuc

    # Empty Capsid in Cytosol dynamics (Eq. 10)
    d_EmptyCapCyto_dt = k_secrete * EmptyCapNuc - mu * EmptyCapCyto

    # Full Capsid in Cytosol dynamics (Eq. 11)
    d_FullCapCyto_dt = k_secrete * FullCapNuc - mu * FullCapCyto

    return [d_ExComplex_dt, d_EndosComplex_dt, d_CytoComplex_dt,
            d_NucPlasmid_H_dt, d_NucPlasmid_P_dt, d_NucPlasmid_V_dt,
            d_NucPlasmid_P_bound_dt, d_RepProtein_dt, d_VP_dt,
            d_vDNA_dt, d_EmptyCapNuc_dt, d_CapRepComplex_dt,
            d_FullCapNuc_dt, d_EmptyCapCyto_dt, d_FullCapCyto_dt]

def run_single_simulation(params):
    """
    Runs and plots a single simulation with the given parameters.
    This function generates the plots similar to Figure 4 in the paper.
    """
    print("--- Running Single Simulation (1:1:1 Ratio) ---")
    # --- Initial Conditions ---
    y0 = np.zeros(15)
    initial_total_plasmids = 3 * 7.6e4
    y0[0] = initial_total_plasmids # All plasmids start as extracellular complexes

    # --- Simulation ---
    t_span = [0, 60]
    t_eval = np.linspace(t_span[0], t_span[1], 300)

    sol = solve_ivp(
        raav_mechanistic_model, t_span, y0, args=(params,),
        dense_output=True, t_eval=t_eval, method='BDF'
    )

    # --- Process and Plot Results ---
    y_sol = sol.y
    vDNA = y_sol[9, :]
    FullCapNuc = y_sol[12, :]
    FullCapCyto = y_sol[14, :]
    EmptyCapNuc = y_sol[10, :]
    EmptyCapCyto = y_sol[13, :]
    CapRepComplex = y_sol[11, :]

    FullVirion = FullCapNuc + FullCapCyto
    TotalCapsid = EmptyCapNuc + FullCapNuc + EmptyCapCyto + FullCapCyto + CapRepComplex

    # Create plots similar to Figure 4 in the paper
    plt.style.use('seaborn-v0_8-whitegrid')
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
    fig.suptitle('rAAV Production Dynamics Simulation (Nguyen et al., 2021 Model)', fontsize=16)

    ax1.plot(sol.t, vDNA, 'k-', label='Replicated viral DNA (vDNA)', linewidth=2)
    ax1.plot(sol.t, FullVirion, 'r-', label='Full Virions', linewidth=2)
    ax1.set_xlabel('Time (hours post-transfection)', fontsize=12)
    ax1.set_ylabel('Copies per Cell', fontsize=12)
    ax1.set_title('Viral DNA Replication and Packaging', fontsize=14)
    ax1.legend()
    ax1.set_ylim(bottom=0)
    ax1.grid(True)

    ax2.plot(sol.t, TotalCapsid, 'b-', label='Total Capsids', linewidth=2)
    ax2.plot(sol.t, FullVirion, 'r-', label='Full Virions', linewidth=2)
    ax2.set_xlabel('Time (hours post-transfection)', fontsize=12)
    ax2.set_ylabel('Capsids per Cell (log scale)', fontsize=12)
    ax2.set_title('Total Capsid and Full Virion Production', fontsize=14)
    ax2.set_yscale('log')
    ax2.legend()
    ax2.grid(True, which="both", ls="--")

    plt.tight_layout(rect=[0, 0, 1, 0.96])
    plt.show()

def run_plasmid_ratio_comparison(base_params):
    """
    Runs simulations for different plasmid ratios and plots a comparison.
    This function demonstrates the model's predictive capability, similar
    to the validation in Figure 5 of the paper.
    """
    print("\n--- Running Plasmid Ratio Comparison Simulation ---")
    ratios_to_test = {
        '3:1:1': (3, 1, 1),
        '2:1.5:1': (2, 1.5, 1),
        '1:1:1': (1, 1, 1),
        '1:1:2': (1, 1, 2),
    }

    results = {}
    final_yields = []

    t_span = [0, 60]
    t_eval = np.linspace(t_span[0], t_span[1], 300)

    for name, ratio_values in ratios_to_test.items():
        print(f"Simulating ratio {name}...")
        sim_params = base_params.copy()
        total_ratio = sum(ratio_values)
        sim_params['plasmid_ratios'] = {
            'helper': ratio_values[0] / total_ratio,
            'packaging': ratio_values[1] / total_ratio,
            'vector': ratio_values[2] / total_ratio
        }

        y0 = np.zeros(15)
        initial_total_plasmids = 3 * 7.6e4
        y0[0] = initial_total_plasmids

        sol = solve_ivp(
            raav_mechanistic_model, t_span, y0, args=(sim_params,),
            dense_output=True, t_eval=t_eval, method='BDF'
        )

        FullVirion = sol.y[12, :] + sol.y[14, :]
        results[name] = {'t': sol.t, 'FullVirion': FullVirion}
        final_yields.append(FullVirion[-1])

    # --- Plot Comparison Results ---
    # 1. Time-series plot
    fig1, ax1 = plt.subplots(figsize=(10, 6))
    for name, result in results.items():
        ax1.plot(result['t'], result['FullVirion'], label=f'Ratio {name}', linewidth=2)

    ax1.set_title('Impact of Plasmid Ratio on Full Virion Production', fontsize=16)
    ax1.set_xlabel('Time (hours post-transfection)', fontsize=12)
    ax1.set_ylabel('Full Virions per Cell', fontsize=12)
    ax1.legend()
    ax1.grid(True)
    ax1.set_ylim(bottom=0)

    # 2. Bar chart of normalized final yields
    normalized_yields = np.array(final_yields) / max(final_yields)
    ratio_labels = list(ratios_to_test.keys())

    fig2, ax2 = plt.subplots(figsize=(10, 6))
    bars = ax2.bar(ratio_labels, normalized_yields, color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'])

    ax2.set_title('Normalized Full Virion Yield at 60h (Similar to Fig. 5)', fontsize=16)
    ax2.set_xlabel('Plasmid Molecular Ratio (Helper:Packaging:Vector)', fontsize=12)
    ax2.set_ylabel('Normalized Full Virion Yield', fontsize=12)
    ax2.set_ylim(0, 1.1)
    ax2.bar_label(bars, fmt='%.2f')

    plt.tight_layout()
    plt.show()


if __name__ == '__main__':
    # --- Model Parameters from Table 1 of Nguyen et al. (2021) ---
    # Using values fitted to in-house measurements where available
    base_params = {
        # Plasmid Delivery
        'k_uptake': 1.19e-3,           # h^-1
        'k_escape': 6.00e-3,            # h^-1 (fixed from literature)
        'k_nuclear_entry': 4.30e-3,     # h^-1
        'k_plasmid_degrade': 1.95e-2,   # h^-1
        # Viral Synthesis
        'k_Rep_syn': 6.50e4,            # molecule/cell/h
        'k_Cap_syn': 6.50e4,            # molecule/cell/h
        'k_VP_degrade': 2.77e-1,        # h^-1 (fixed from literature)
        'k_Rep_protein_degrade': 2.45e-2, # h^-1 (fixed from literature)
        'k_DNA_rep': 3.10e-7,           # (molecule/cell)^-2 * h^-1
        'k_assembly': 1.00e5,           # h^-1 (fast step assumption)
        'k_secrete': 1.00e5,            # h^-1 (fast step assumption)
        'k_DNA_pack': 8.18e-2,          # (molecule/cell)^-1 * h^-1
        'k_Rep_bind_plasmid': 3.38e-5,  # (molecule/cell)^-1 * h^-1
        'k_Rep_bind_capsid': 5.70e-3,   # (molecule/cell)^-1 * h^-1
        # Cell doubling time of ~30h from paper
        'mu': np.log(2) / 30,           # h^-1
        # Initial plasmid ratios (1:1:1) will be set in the simulation functions
    }

    # Run the original single simulation for the 1:1:1 case
    single_sim_params = base_params.copy()
    single_sim_params['plasmid_ratios'] = {'helper': 1/3, 'packaging': 1/3, 'vector': 1/3}
    run_single_simulation(single_sim_params)

    # Run the new comparison simulation
    run_plasmid_ratio_comparison(base_params)